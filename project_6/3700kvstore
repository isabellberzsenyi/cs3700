#!/usr/bin/env python2

import sys, socket, select, time, json, random

# Your ID number
my_id = sys.argv[1]

# The ID numbers of all the other replicas
replica_ids = sys.argv[2:]

class Replica:
	def __init__(self, id, replica_ids):
		self.id = id
		self.replica_ids = replica_ids
		self.last = 0
		self.current_term = 0
		self.voted_for = None
		self.log = []
		self.kv_store = {}
		self.commit_index = 0
		self.last_applied = 0
		self.next_index = None
		self.match_index = None
		self.number_votes = 0

	def receiveVote(self, response):
		if response:
			self.number_votes += 1

		if self.number_votes >= ((self.replica_ids / 2) + 1):
		  # we are the leader now

	def respondVote(self, term, candidateId, lastLogIdx, lastLogTerm, socket):
	  msg = {'src': self.id, 'dst': candidateId, 'type': 'respond_vote'}
		if term < self.current_term:
			msg['response'] = False
			socket.send(json.dumps(msg))
		elif (self.voted_for is not None or self.voted_for == candidateId) and (lastLogTerm >= self.current_term or (lastLogTerm == self.currentTerm and lastLogIdx >= (len(self.log) - 1)):
			msg['response'] = True
			sock.send(json.dumps(msg))

	def requestVote(self, socket):
	  self.current_term += 1
    self.number_votes = 0

	  for replica in replica_ids:
			msg = {'src': self.id, 'dst ': replica, 'type': 'request_vote', 'term': self.current_term, 'candidateId': self.id, 'lastLogIndex': len(self.log) - 1, 'lastLogTerm': self.log[-1]['term']}
			socket.send(json.dumps(msg))

	def run(self):
		# Connect to the network. All messages to/from other replicas and clients will
		# occur over this socket
		sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
		sock.connect(self.id)

		while True:
			ready = select.select([sock], [], [], 0.1)[0]
			
			if sock in ready:
				msg_raw = sock.recv(32768)
				
				if len(msg_raw) == 0: continue
				msg = json.loads(msg_raw)
				
				print '%s' % (str(msg))
				# For now, ignore get() and put() from clients
				if msg['type'] in ['get', 'put']:
					print 'sending type fail'
					msg = {'src': self.id, 'dst': random.choice(self.replica_ids), 'leader': 'FFFF', 'type': 'fail'}
					sock.send(json.dumps(msg))
				# Handle noop messages. This may be removed from your final implementation
				elif msg['type'] == 'noop':
					print '%s received a NOOP from %s' % (msg['dst'], msg['src'])
				
			clock = time.time()
			if clock-self.last > 2:
				# Send a no-op message to a random peer every two seconds, just for fun
				# You definitely want to remove this from your implementation
				msg = {'src': self.id, 'dst': random.choice(self.replica_ids), 'leader': 'FFFF', 'type': 'noop'}
				sock.send(json.dumps(msg))
				print '%s sending a NOOP to %s' % (msg['src'], msg['dst'])
				self.last = clock

if __name__ == '__main__':
	replica = Replica(my_id, replica_ids)
	replica.run()
